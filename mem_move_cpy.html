<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animação e Explicação memcpy/memmove</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            background-color: #f4f4f4;
            color: #333;
            margin-bottom: 50px;
        }
        h1, h2, h3 {
            color: #0056b3;
            text-align: center;
        }
        p {
            text-align: center;
        }

        /* --- Navegação entre seções --- */
        .tab-buttons {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .tab-buttons button {
            padding: 10px 20px;
            font-size: 1.1em;
            cursor: pointer;
            border: 1px solid #007bff;
            border-radius: 5px;
            background-color: #e0e0e0;
            color: #007bff;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .tab-buttons button.active {
            background-color: #007bff;
            color: white;
        }
        .tab-buttons button:hover:not(.active) {
            background-color: #cce5ff;
        }

        /* --- Conteiner principal de conteúdo --- */
        .content-section {
            display: none; /* Oculta todas as seções por padrão */
            width: 95%;
            max-width: 1200px;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            box-sizing: border-box;
        }
        .content-section.active {
            display: flex; /* Exibe a seção ativa */
            flex-direction: column;
            align-items: center;
        }

        /* --- Layout da seção de animação (mantido do anterior) --- */
        .animation-layout {
            display: flex;
            width: 100%;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .left-panel {
            flex: 2;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .right-panel {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            background-color: #f8f8f8; /* Fundo para o código */
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            padding: 15px;
        }

        #memory-container {
            display: flex;
            margin-top: 20px;
            border: 2px solid #ccc;
            padding: 10px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            flex-wrap: wrap;
            justify-content: center;
        }
        .memory-cell {
            width: 40px;
            height: 40px;
            border: 1px solid #aaa;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1.2em;
            margin: 2px;
            background-color: #e0e0e0;
            transition: background-color 0.3s, border-color 0.3s;
            position: relative;
            border-radius: 4px;
        }
        .memory-cell.src { background-color: #d1e7dd; border-color: #28a745; }
        .memory-cell.dest { background-color: #ffeeba; border-color: #ffc107; }
        .memory-cell.active-src { background-color: #28a745; color: white; box-shadow: 0 0 8px rgba(40,167,69,0.7); }
        .memory-cell.active-dest { background-color: #ffc107; color: #333; box-shadow: 0 0 8px rgba(255,193,7,0.7); }
        .memory-cell.copied { background-color: #cce5ff; border-color: #007bff; }
        .memory-cell .index { font-size: 0.7em; color: #666; position: absolute; bottom: 2px; }

        .controls {
            margin-top: 30px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .controls button {
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            transition: background-color 0.3s ease;
        }
        .controls button:hover { background-color: #0056b3; }
        .controls button:disabled { background-color: #cccccc; cursor: not-allowed; }

        #info {
            margin-top: 20px;
            font-size: 1.1em;
            font-weight: bold;
            color: #555;
            min-height: 25px;
            text-align: center;
        }
        #explanation {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            background-color: #e9ecef;
            border-radius: 8px;
            width: 100%;
            min-height: 80px;
            font-size: 1.0em;
            color: #495057;
            line-height: 1.5;
            text-align: center;
            box-sizing: border-box;
        }

        /* Código */
        #code-display {
            background-color: #282c34; /* Dark background for code */
            color: #abb2bf; /* Light text for code */
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Fira Code', 'Courier New', Courier, monospace;
            font-size: 0.95em;
            line-height: 1.4;
            tab-size: 4;
            margin-top: 20px;
            max-height: 400px;
        }
        .code-line {
            padding: 2px 5px;
            border-left: 3px solid transparent;
            transition: background-color 0.2s;
        }
        .code-line.active-line {
            background-color: #3b3f46; /* Slightly lighter for active line */
            border-left-color: #61afef; /* Blue border */
            font-weight: bold;
        }

        /* --- Estilos da Seção de Explicação --- */
        .explanation-content {
            padding: 10px 0;
            width: 100%;
            max-width: 800px; /* Limita a largura do texto de explicação */
            margin: 0 auto;
        }
        .explanation-content h2 {
            color: #007bff;
            margin-top: 40px;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 5px;
        }
        .explanation-content h3 {
            color: #495057;
            margin-top: 25px;
            text-align: left; /* Alinha os títulos menores à esquerda */
        }
        .explanation-content p {
            text-align: left; /* Alinha parágrafos à esquerda */
            margin-bottom: 10px;
        }
        .explanation-content ul {
            list-style-type: disc;
            margin-left: 20px;
            text-align: left;
        }
        .explanation-content li {
            margin-bottom: 8px;
        }
        .explanation-content pre {
            background-color: #282c34;
            color: #abb2bf;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Fira Code', 'Courier New', Courier, monospace;
            font-size: 0.95em;
            line-height: 1.4;
            tab-size: 4;
            margin-top: 15px;
            margin-bottom: 15px;
        }
        .explanation-content pre .comment { color: #5c6370; }
        .explanation-content pre .keyword { color: #c678dd; }
        .explanation-content pre .type { color: #e06c75; }
        .explanation-content pre .variable { color: #e5c07b; }
        .explanation-content pre .function { color: #61afef; }
        .explanation-content pre .string { color: #98c379; }
        .explanation-content pre .number { color: #d19a66; }
        .explanation-content pre .macro { color: #56b6c2; }

        .explanation-content .section-header {
            font-weight: bold;
            color: #007bff;
            text-align: left;
        }
        .explanation-content .highlight {
            background-color: #fff3cd;
            padding: 2px 4px;
            border-radius: 3px;
        }
        .explanation-content table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            margin-bottom: 20px;
        }
        .explanation-content th, .explanation-content td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }
        .explanation-content th {
            background-color: #f2f2f2;
            font-weight: bold;
            color: #555;
        }
        .explanation-content tr:nth-child(even) {
            background-color: #f9f9f9;
        }
    </style>
</head>
<body>
    <h1>Animação e Explicação de Funções de Memória</h1>
    <p>Explore como `memcpy` e `memmove` funcionam com uma animação interativa e explicações detalhadas, seguindo as normas da Escola 42.</p>

    <div class="tab-buttons">
        <button id="showAnimationBtn" class="active" onclick="showSection('animation')">Ver Animação</button>
        <button id="showExplanationBtn" onclick="showSection('explanation')">Ver Explicação Detalhada</button>
    </div>

    <div id="animationSection" class="content-section active">
        <p>Simulação da cópia de 5 bytes do índice 0 para o índice 2.</p>
        <p><strong>Array Original: "ABCDEFGHIJ"</strong></p>

        <div class="animation-layout">
            <div class="left-panel">
                <div id="memory-container"></div>
                <div class="controls">
                    <button id="memcpyBtn" onclick="startAnimation('memcpy')">Simular `memcpy` (Perigoso)</button>
                    <button id="memmoveBtn" onclick="startAnimation('memmove')">Simular `memmove` (Seguro)</button>
                    <button id="nextBtn" onclick="nextStep()" disabled>Next Step</button>
                    <button id="resetBtn" onclick="resetAnimation()">Reiniciar</button>
                </div>
                <div id="info"></div>
                <div id="explanation"></div>
            </div>

            <div class="right-panel">
                <h2>Código da Função</h2>
                <div id="code-display">
                    </div>
            </div>
        </div>
    </div>

    <div id="explanationSection" class="content-section">
        <div class="explanation-content">
            <h1>Entendendo `memcpy` e `memmove` em C</h1>
            <p>Um guia detalhado sobre duas das funções mais importantes para manipulação de memória na biblioteca padrão C, com foco nas melhores práticas e normas de codificação.</p>

            <hr>

            <h2>Visão Geral</h2>
            <p>
                As funções <code>memcpy</code> e <code>memmove</code> são utilitários fundamentais na linguagem C para **copiar blocos de memória**. Ambas são declaradas no cabeçalho <code>&lt;string.h&gt;</code>. Embora suas finalidades pareçam similares, a principal diferença reside no tratamento de **áreas de memória sobrepostas**. Compreender essa distinção é crucial para escrever código seguro e eficiente em C.
            </p>

            <hr>

            <h2>A Função `memcpy`</h2>
            <h3>O que faz?</h3>
            <p>
                A função <code>memcpy</code> copia <code>n</code> bytes da área de memória apontada por <code>src</code> para a área de memória apontada por <code>dest</code>. Ela é otimizada para ser muito rápida, mas assume uma condição crítica: as **áreas de memória de origem e destino NÃO PODEM se sobrepor**. Se houver sobreposição, o comportamento de <code>memcpy</code> é **indefinido**, o que pode levar a resultados imprevisíveis ou corrupção de dados.
            </p>
            <p>
                Use <code>memcpy</code> apenas quando você tem **certeza absoluta** de que a região de memória de onde você está lendo (origem) e a região para onde você está escrevendo (destino) são completamente independentes.
            </p>

            <h3>Assinatura da Biblioteca (`<string.h>`)</h3>
            <pre><span class="keyword">void</span> <span class="macro">*</span><span class="function">memcpy</span><span class="macro">(</span><span class="keyword">void</span> <span class="macro">*</span><span class="variable">dest</span><span class="keyword">,</span> <span class="keyword">const</span> <span class="keyword">void</span> <span class="macro">*</span><span class="variable">src</span><span class="keyword">,</span> <span class="type">size_t</span> <span class="variable">n</span><span class="macro">);</span></pre>
            <ul>
                <li><code>dest</code>: Um ponteiro para a área de memória de destino.</li>
                <li><code>src</code>: Um ponteiro para a área de memória de origem.</li>
                <li><code>n</code>: O número de bytes a serem copiados.</li>
                <li>**Retorno:** Um ponteiro para <code>dest</code>.</li>
            </ul>

            <h3>Implementação Padrão 42 para `ft_memcpy`</h3>
            <p>
                Na Escola 42, você implementaria sua própria versão desta função, geralmente com o prefixo <code>ft_</code>. A implementação deve ser robusta, porém, no caso de <code>memcpy</code>, o tratamento de sobreposição é explicitamente **não** esperado ou requerido, pois o comportamento é indefinido.
            </p>
            <pre><span class="comment">/* ************************************************************************** */</span>
<span class="comment">/* */</span>
<span class="comment">/* :::      ::::::::   */</span>
<span class="comment">/* ft_memcpy.c                                        :+:      :+:    :+:   */</span>
<span class="comment">/* +:+ +:+         +:+     */</span>
<span class="comment">/* By: &lt;seu_login&gt; &lt;seu_email&gt;                    +#+  +:+       +#+        */</span>
<span class="comment">/* +#+#+#+#+#+   +#+           */</span>
<span class="comment">/* Created: YYYY/MM/DD HH:MM:SS by &lt;seu_login&gt;      #+#    #+#             */</span>
<span class="comment">/* Updated: YYYY/MM/DD HH:MM:SS by &lt;seu_login&gt;     ###   ########.fr       */</span>
<span class="comment">/* */</span>
<span class="comment">/* ************************************************************************** */</span>

<span class="comment">#include &lt;stddef.h&gt;</span> <span class="comment">// Para size_t</span>

<span class="keyword">void</span>	<span class="macro">*</span><span class="function">ft_memcpy</span><span class="macro">(</span><span class="keyword">void</span> <span class="macro">*</span><span class="variable">dest</span><span class="keyword">,</span> <span class="keyword">const</span> <span class="keyword">void</span> <span class="macro">*</span><span class="variable">src</span><span class="keyword">,</span> <span class="type">size_t</span> <span class="variable">n</span><span class="macro">)</span>
<span class="macro">{</span>
	<span class="comment">// 1. Crio ponteiros char* para manipular byte a byte.</span>
	<span class="comment">//    Isso é necessário pois void* não permite aritmética de ponteiros.</span>
	<span class="type">char</span>		<span class="macro">*</span><span class="variable">d</span><span class="macro">;</span>
	<span class="type">const char</span>	<span class="macro">*</span><span class="variable">s</span><span class="macro">;</span>
	<span class="type">size_t</span>		<span class="variable">i</span><span class="macro">;</span>

	<span class="comment">// 2. Se dest ou src forem NULL, e 'n' não for 0, o comportamento é indefinido.</span>
	<span class="comment">//    A função da libc não garante nada para NULLs.</span>
	<span class="comment">//    Para 42, muitas vezes pedem para não tratar NULL para testar UB.</span>
	<span class="comment">//    Se for para retornar NULL em caso de NULL, adicione:</span>
	<span class="comment">//    if (!dest && !src) return (NULL);</span>
	<span class="comment">//    mas geralmente a prática é apenas retornar dest se n == 0.</span>
	<span class="keyword">if</span> <span class="macro">(</span><span class="variable">dest</span> <span class="macro">==</span> <span class="number">NULL</span> <span class="macro">&amp;&amp;</span> <span class="variable">src</span> <span class="macro">==</span> <span class="number">NULL</span> <span class="macro">&amp;&amp;</span> <span class="variable">n</span> <span class="macro">!=</span> <span class="number">0</span><span class="macro">)</span>
		<span class="keyword">return</span> <span class="variable">NULL</span><span class="macro">;</span>

	<span class="variable">d</span> <span class="macro">=</span> <span class="macro">(</span><span class="type">char</span> <span class="macro">*</span><span class="macro">)</span><span class="variable">dest</span><span class="macro">;</span>
	<span class="variable">s</span> <span class="macro">=</span> <span class="macro">(</span><span class="type">const char</span> <span class="macro">*</span><span class="macro">)</span><span class="variable">src</span><span class="macro">;</span>
	<span class="variable">i</span> <span class="macro">=</span> <span class="number">0</span><span class="macro">;</span>

	<span class="comment">// 3. Copia 'n' bytes, um por um.</span>
	<span class="comment">//    A cópia é sempre do início para o fim.</span>
	<span class="keyword">while</span> <span class="macro">(</span><span class="variable">i</span> <span class="macro"><</span> <span class="variable">n</span><span class="macro">)</span>
	<span class="macro">{</span>
		<span class="variable">d</span><span class="macro">[</span><span class="variable">i</span><span class="macro">]</span> <span class="macro">=</span> <span class="variable">s</span><span class="macro">[</span><span class="variable">i</span><span class="macro">];</span>
		<span class="variable">i</span><span class="macro">++;</span>
	<span class="macro">}</span>

	<span class="comment">// 4. Retorna o ponteiro original de destino.</span>
	<span class="keyword">return</span> <span class="variable">dest</span><span class="macro">;</span>
<span class="macro">}</span></pre>
            <p class="section-header">Elementos da Biblioteca Padrão C (`<string.h>`) Utilizados:</p>
            <ul>
                <li>**Assinatura:** A função segue o mesmo protótipo (<code>void *func(void *dest, const void *src, size_t n)</code>).</li>
                <li>**Tipo de Retorno:** <code>void *</code> (um ponteiro genérico).</li>
                <li>**Parâmetros:** <code>void *dest</code> (destino), <code>const void *src</code> (origem constante), <code>size_t n</code> (número de bytes).</li>
                <li>**Tipo `size_t`:** Usado para representar tamanhos e contagens de bytes, garantindo portabilidade e capacidade de manipular grandes blocos de memória. Vem de <code>&lt;stddef.h&gt;</code>, que é frequentemente incluído por <code>&lt;string.h&gt;</code> ou outras bibliotecas comuns.</li>
            </ul>

            <hr>

            <h2>A Função `memmove`</h2>
            <h3>O que faz?</h3>
            <p>
                A função <code>memmove</code> também copia <code>n</code> bytes da área de memória apontada por <code>src</code> para a área de memória apontada por <code>dest</code>. A diferença crucial é que <code>memmove</code> **GARANTE que a cópia seja feita corretamente mesmo quando as áreas de memória de origem e destino se sobrepõem**.
            </p>
            <p>
                Para lidar com a sobreposição, <code>memmove</code> verifica a relação entre os ponteiros de origem e destino. Se o destino começar à direita da origem (<code>dest > src</code>) e houver sobreposição, ela copia os bytes de **trás para frente**. Caso contrário (sem sobreposição, ou destino à esquerda da origem), ela copia de **frente para trás**. Essa lógica evita que dados ainda não lidos da origem sejam sobrescritos pelo destino.
            </p>
            <p>
                Use <code>memmove</code> sempre que houver a **possibilidade** de sobreposição, ou se você não tiver certeza sobre o relacionamento das áreas de memória. É a opção mais segura.
            </p>

            <h3>Assinatura da Biblioteca (`<string.h>`)</h3>
            <pre><span class="keyword">void</span> <span class="macro">*</span><span class="function">memmove</span><span class="macro">(</span><span class="keyword">void</span> <span class="macro">*</span><span class="variable">dest</span><span class="keyword">,</span> <span class="keyword">const</span> <span class="keyword">void</span> <span class="macro">*</span><span class="variable">src</span><span class="keyword">,</span> <span class="type">size_t</span> <span class="variable">n</span><span class="macro">);</span></pre>
            <ul>
                <li><code>dest</code>: Um ponteiro para a área de memória de destino.</li>
                <li><code>src</code>: Um ponteiro para a área de memória de origem.</li>
                <li><code>n</code>: O número de bytes a serem copiados.</li>
                <li>**Retorno:** Um ponteiro para <code>dest</code>.</li>
            </ul>

            <h3>Implementação Padrão 42 para `ft_memmove`</h3>
            <p>
                A implementação de <code>ft_memmove</code> é mais complexa devido à necessidade de lidar com a sobreposição de forma segura.
            </p>
            <pre><span class="comment">/* ************************************************************************** */</span>
<span class="comment">/* */</span>
<span class="comment">/* :::      ::::::::   */</span>
<span class="comment">/* ft_memmove.c                                       :+:      :+:    :+:   */</span>
<span class="comment">/* +:+ +:+         +:+     */</span>
<span class="comment">/* By: &lt;seu_login&gt; &lt;seu_email&gt;                    +#+  +:+       +#+        */</span>
<span class="comment">/* +#+#+#+#+#+   +#+           */</span>
<span class="comment">/* Created: YYYY/MM/DD HH:MM:SS by &lt;seu_login&gt;      #+#    #+#             */</span>
<span class="comment">/* Updated: YYYY/MM/DD HH:MM:SS by &lt;seu_login&gt;     ###   ########.fr       */</span>
<span class="comment">/* */</span>
<span class="comment">/* ************************************************************************** */</span>

<span class="comment">#include &lt;stddef.h&gt;</span> <span class="comment">// Para size_t</span>

<span class="keyword">void</span>	<span class="macro">*</span><span class="function">ft_memmove</span><span class="macro">(</span><span class="keyword">void</span> <span class="macro">*</span><span class="variable">dest</span><span class="keyword">,</span> <span class="keyword">const</span> <span class="keyword">void</span> <span class="macro">*</span><span class="variable">src</span><span class="keyword">,</span> <span class="type">size_t</span> <span class="variable">n</span><span class="macro">)</span>
<span class="macro">{</span>
	<span class="comment">// 1. Crio ponteiros char* para manipular byte a byte.</span>
	<span class="comment">//    'd' para o destino (modificável), 's' para a origem (constante).</span>
	<span class="type">char</span>		<span class="macro">*</span><span class="variable">d</span><span class="macro">;</span>
	<span class="type">const char</span>	<span class="macro">*</span><span class="variable">s</span><span class="macro">;</span>
	<span class="type">size_t</span>		<span class="variable">i</span><span class="macro">;</span>

	<span class="comment">// 2. Se 'n' for 0, não há nada para copiar. Retorna o destino.</span>
	<span class="comment">//    Se dest ou src forem NULL, e 'n' não for 0, o comportamento é indefinido.</span>
	<span class="comment">//    A função da libc não garante nada para NULLs.</span>
	<span class="comment">//    Para 42, muitas vezes pedem para não tratar NULL para testar UB.</span>
	<span class="comment">//    Se for para retornar NULL em caso de NULL, adicione:</span>
	<span class="comment">//    if (!dest && !src) return (NULL);</span>
	<span class="keyword">if</span> <span class="macro">(</span><span class="variable">n</span> <span class="macro">==</span> <span class="number">0</span><span class="macro">)</span>
		<span class="keyword">return</span> <span class="variable">dest</span><span class="macro">;</span>

	<span class="variable">d</span> <span class="macro">=</span> <span class="macro">(</span><span class="type">char</span> <span class="macro">*</span><span class="macro">)</span><span class="variable">dest</span><span class="macro">;</span>
	<span class="variable">s</span> <span class="macro">=</span> <span class="macro">(</span><span class="type">const char</span> <span class="macro">*</span><span class="macro">)</span><span class="variable">src</span><span class="macro">;</span>

	<span class="comment">// 3. Lógica para lidar com sobreposição:</span>
	<span class="comment">//    Se o ponteiro de destino 'd' for MAIOR que o ponteiro de origem 's'</span>
	<span class="comment">//    E o destino 'd' estiver DENTRO do bloco de origem (s até s+n),</span>
	<span class="comment">//    então há sobreposição e o destino está à direita da origem.</span>
	<span class="comment">//    Nesse caso, copiar do início para o fim sobrescreveria dados AINDA NÃO LIDOS.</span>
	<span class="comment">//    Portanto, copia-se de TRÁS PARA FRENTE.</span>
	<span class="keyword">if</span> <span class="macro">(</span><span class="variable">d</span> <span class="macro">></span> <span class="variable">s</span> <span class="macro">&amp;&amp;</span> <span class="variable">d</span> <span class="macro"><</span> <span class="variable">s</span> <span class="macro">+</span> <span class="variable">n</span><span class="macro">)</span>
	<span class="macro">{</span>
		<span class="comment">// Cópia de trás para frente (high to low addresses)</span>
		<span class="variable">i</span> <span class="macro">=</span> <span class="variable">n</span><span class="macro">;</span>
		<span class="keyword">while</span> <span class="macro">(</span><span class="variable">i</span> <span class="macro">></span> <span class="number">0</span><span class="macro">)</span>
		<span class="macro">{</span>
			<span class="variable">i</span><span class="macro">--;</span>
			<span class="variable">d</span><span class="macro">[</span><span class="variable">i</span><span class="macro">]</span> <span class="macro">=</span> <span class="variable">s</span><span class="macro">[</span><span class="variable">i</span><span class="macro">];</span>
		<span class="macro">}</span>
	<span class="macro">}</span>
	<span class="comment">// 4. Caso contrário (sem sobreposição, ou destino à esquerda/igual à origem),</span>
	<span class="comment">//    copia-se de frente para trás. Isso é seguro nesses cenários.</span>
	<span class="keyword">else</span>
	<span class="macro">{</span>
		<span class="comment">// Cópia de frente para trás (low to high addresses)</span>
		<span class="variable">i</span> <span class="macro">=</span> <span class="number">0</span><span class="macro">;</span>
		<span class="keyword">while</span> <span class="macro">(</span><span class="variable">i</span> <span class="macro"><</span> <span class="variable">n</span><span class="macro">)</span>
		<span class="macro">{</span>
			<span class="variable">d</span><span class="macro">[</span><span class="variable">i</span><span class="macro">]</span> <span class="macro">=</span> <span class="variable">s</span><span class="macro">[</span><span class="variable">i</span><span class="macro">];</span>
			<span class="variable">i</span><span class="macro">++;</span>
		<span class="macro">}</span>
	<span class="macro">}</span>

	<span class="comment">// 5. Retorna o ponteiro original de destino.</span>
	<span class="keyword">return</span> <span class="variable">dest</span><span class="macro">;</span>
<span class="macro">}</span></pre>
            <p class="section-header">Elementos da Biblioteca Padrão C (`<string.h>`) Utilizados:</p>
            <ul>
                <li>**Assinatura:** A função segue o mesmo protótipo.</li>
                <li>**Tipo de Retorno:** <code>void *</code>.</li>
                <li>**Parâmetros:** <code>void *dest</code>, <code>const void *src</code>, <code>size_t n</code>.</li>
                <li>**Tipo `size_t`:** Essencial para tamanhos de bloco de memória.</li>
                <li>**Manuseio de `void *`:** A conversão para `char *` é o padrão para manipular a memória byte a byte.</li>
            </ul>

            <hr>

            <h2>Diferença Principal: Sobreposição de Memória</h2>
            <p>A tabela abaixo resume a diferença crucial entre <code>memcpy</code> e <code>memmove</code>:</p>
            <table>
                <thead>
                    <tr>
                        <th>Característica</th>
                        <th>`memcpy`</th>
                        <th>`memmove`</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>**Tratamento de Sobreposição**</td>
                        <td><span class="highlight">**NÃO GARANTIDO.** Comportamento Indefinido (Undefined Behavior - UB) se as regiões se sobrepõem.</span></td>
                        <td><span class="highlight">**GARANTIDO.** Lida corretamente com sobreposição, alterando a direção da cópia se necessário.</span></td>
                    </tr>
                    <tr>
                        <td>**Performance**</td>
                        <td>Geralmente **mais rápida**, pois não precisa verificar sobreposição.</td>
                        <td>Pode ser ligeiramente **mais lenta**, devido à verificação de sobreposição e potencial cópia reversa.</td>
                    </tr>
                    <tr>
                        <td>**Uso Recomendado**</td>
                        <td>Quando você tem **certeza absoluta** que as áreas de memória **não se sobrepõem** (ex: copiando para um buffer novo).</td>
                        <td>Quando há **qualquer possibilidade de sobreposição** (ex: deslocando elementos dentro do mesmo array), ou se você **não tem certeza**. É a opção mais segura.</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <script>
        const initialArray = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
        let currentArray = [...initialArray];
        const memContainer = document.getElementById('memory-container');
        const infoDisplay = document.getElementById('info');
        const explanationDisplay = document.getElementById('explanation');
        const memcpyBtn = document.getElementById('memcpyBtn');
        const memmoveBtn = document.getElementById('memmoveBtn');
        const nextBtn = document.getElementById('nextBtn');
        const resetBtn = document.getElementById('resetBtn');
        const codeDisplay = document.getElementById('code-display');

        const animationSection = document.getElementById('animationSection');
        const explanationSection = document.getElementById('explanationSection');
        const showAnimationBtn = document.getElementById('showAnimationBtn');
        const showExplanationBtn = document.getElementById('showExplanationBtn');

        const n = 5; // Número de bytes a copiar
        const srcStart = 0; // Início da origem
        const destStart = 2; // Início do destino

        let animationRunning = false;
        let currentAnimationType = '';
        let step = 0; // Controla o passo atual da animação
        let resolveNextStep = null; // Função para resolver a promessa do next step
        let copyDirection = ''; // 'forward' ou 'backward' para memmove

        // Códigos das funções para exibição
        const memcpyCode = `void *my_memcpy(void *dest, const void *src, size_t n) {
    char *d = (char *)dest;
    const char *s = (const char *)src;

    for (size_t i = 0; i < n; i++) {
        d[i] = s[i];
    }
    return dest;
}`;

        const memmoveCode = `void *my_memmove(void *dest, const void *src, size_t n) {
    char *d = (char *)dest;
    const char *s = (const char *)src;

    if (d > s && d < s + n) {
        // Cópia para trás (do fim para o início)
        for (size_t i = n; i > 0; i--) {
            d[i - 1] = s[i - 1];
        }
    } else {
        // Cópia para frente (do início para o fim)
        for (size_t i = 0; i < n; i++) {
            d[i] = s[i];
        }
    }
    return dest;
}`;

        // --- Funções de controle de seção ---
        function showSection(sectionId) {
            // Esconde todas as seções
            document.querySelectorAll('.content-section').forEach(section => {
                section.classList.remove('active');
            });
            // Desativa todos os botões de aba
            document.querySelectorAll('.tab-buttons button').forEach(btn => {
                btn.classList.remove('active');
            });

            // Mostra a seção desejada e ativa o botão correspondente
            if (sectionId === 'animation') {
                animationSection.classList.add('active');
                showAnimationBtn.classList.add('active');
                // Quando volta para a animação, reinicia para um estado limpo
                resetAnimation();
            } else if (sectionId === 'explanation') {
                explanationSection.classList.add('active');
                showExplanationBtn.classList.add('active');
                // Garante que a animação pare se estiver rodando
                if (animationRunning) {
                    resetAnimation();
                }
            }
        }


        // --- Funções de Animação (mantidas do anterior) ---
        function createMemoryDisplay() {
            memContainer.innerHTML = '';
            currentArray.forEach((char, index) => {
                const cell = document.createElement('div');
                cell.classList.add('memory-cell');
                cell.id = `cell-${index}`;
                cell.innerHTML = `<span>${char}</span><span class="index">${index}</span>`;
                if (index >= srcStart && index < srcStart + n) {
                    cell.classList.add('src');
                }
                if (index >= destStart && index < destStart + n) {
                    cell.classList.add('dest');
                }
                memContainer.appendChild(cell);
            });
        }

        function displayCode(code) {
            codeDisplay.innerHTML = '';
            const lines = code.split('\n');
            lines.forEach((line, index) => {
                const lineDiv = document.createElement('div');
                lineDiv.classList.add('code-line');
                lineDiv.id = `code-line-${index}`;
                lineDiv.textContent = line;
                codeDisplay.appendChild(lineDiv);
            });
        }

        function highlightCodeLine(lineNumber) {
            document.querySelectorAll('.code-line').forEach(line => line.classList.remove('active-line'));
            const lineToHighlight = document.getElementById(`code-line-${lineNumber}`);
            if (lineToHighlight) {
                lineToHighlight.classList.add('active-line');
                lineToHighlight.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function clearCodeHighlight() {
            document.querySelectorAll('.code-line').forEach(line => line.classList.remove('active-line'));
        }

        function highlightCells(srcIdx, destIdx, type) {
            document.querySelectorAll('.active-src').forEach(cell => cell.classList.remove('active-src'));
            document.querySelectorAll('.active-dest').forEach(cell => cell.classList.remove('active-dest'));

            const srcCell = document.getElementById(`cell-${srcIdx}`);
            const destCell = document.getElementById(`cell-${destIdx}`);

            if (srcCell) srcCell.classList.add('active-src');
            if (destCell) destCell.classList.add('active-dest');

            infoDisplay.textContent = `Copiando (${type}): De src[${srcIdx}] para dest[${destIdx}]`;
        }

        function updateCellContent(index, newChar) {
            const cell = document.getElementById(`cell-${index}`);
            cell.querySelector('span:first-child').textContent = newChar;
            cell.classList.add('copied');
        }

        async function waitForNextClick() {
            return new Promise(resolve => {
                resolveNextStep = resolve;
                nextBtn.disabled = false;
            });
        }

        function nextStep() {
            if (resolveNextStep) {
                resolveNextStep();
                resolveNextStep = null;
                nextBtn.disabled = true;
            }
        }

        async function animateMemcpyLogic() {
            displayCode(memcpyCode);

            highlightCodeLine(0);
            explanationDisplay.textContent = "Iniciando a função my_memcpy. Ela recebe o destino, a origem e o número de bytes.";
            await waitForNextClick();

            highlightCodeLine(1);
            explanationDisplay.textContent = "Converte o ponteiro de destino 'void*' para 'char*', permitindo manipulação byte a byte.";
            await waitForNextClick();

            highlightCodeLine(2);
            explanationDisplay.textContent = "Converte o ponteiro de origem 'const void*' para 'const char*', para leitura byte a byte.";
            await waitForNextClick();

            highlightCodeLine(8); // Linha do if de NULL
            explanationDisplay.textContent = "Verificando se os ponteiros são NULL. Embora a libc não garanta para NULLs com n!=0, esta é uma verificação defensiva comum em 42. (Neste caso, os ponteiros não são NULL)";
            await waitForNextClick();


            highlightCodeLine(10); // d = (char *)dest;
            explanationDisplay.textContent = "Atribuindo os ponteiros convertidos 'dest' para 'd', 'src' para 's', e inicializando 'i' como 0.";
            highlightCodeLine(11); // s = (const char *)src;
            highlightCodeLine(12); // i = 0;
            await waitForNextClick();


            for (step = 0; step < n; step++) {
                highlightCodeLine(15); // while (i < n) {
                explanationDisplay.textContent = `Verificando a condição do loop: i (${step}) < n (${n}). Condição verdadeira, entrando no loop.`;
                await waitForNextClick();

                const srcIdx = srcStart + step;
                const destIdx = destStart + step;

                highlightCodeLine(17); // d[i] = s[i];
                highlightCells(srcIdx, destIdx, 'memcpy');
                
                let explanationText = `Passo ${step + 1}: Lendo '${currentArray[srcIdx]}' de src[${srcIdx}]`;
                explanationDisplay.textContent = explanationText;
                await waitForNextClick();

                const charToCopy = currentArray[srcIdx];

                explanationText += ` e escrevendo em dest[${destIdx}].`;
                explanationDisplay.textContent = explanationText;
                await waitForNextClick();

                currentArray[destIdx] = charToCopy;
                updateCellContent(destIdx, charToCopy);

                if (step === 2) { 
                    explanationDisplay.textContent = `CRÍTICO! No Passo 1 (i=0), 'A' de src[0] foi copiado para dest[2]. Agora, memcpy tenta ler src[2]. Mas src[2] NÃO É MAIS 'C', é 'A'! memcpy LÊ O VALOR ATUAL. Resultado: 'A' é copiado novamente. **CORRUPÇÃO DE DADOS.**`;
                } else if (srcIdx < destIdx && destIdx < srcStart + n) {
                     const originalSrcValue = initialArray[srcIdx];
                     if (charToCopy !== originalSrcValue) {
                         explanationDisplay.textContent = `**CORRUPÇÃO DETECTADA!** memcpy leu '${charToCopy}' de src[${srcIdx}], mas o valor original lá era '${originalSrcValue}'. Isso ocorreu porque um byte anterior foi copiado para esta posição na memória de origem.`;
                     } else {
                         explanationDisplay.textContent = `Passo ${step + 1}: Caractere '${charToCopy}' copiado com sucesso para dest[${destIdx}].`;
                     }
                } else {
                    explanationDisplay.textContent = `Passo ${step + 1}: Caractere '${charToCopy}' copiado com sucesso para dest[${destIdx}].`;
                }
                await waitForNextClick(); // Pausa após a cópia e explicação
                
                highlightCodeLine(18); // i++;
                explanationDisplay.textContent = `Incrementando 'i' para o próximo byte. i agora é ${step + 1}.`;
                await waitForNextClick();

            }
            highlightCodeLine(15); // Mostra a condição do while pela última vez (false)
            explanationDisplay.textContent = `Verificando a condição do loop: i (${n}) < n (${n}). Condição falsa, saindo do loop.`;
            await waitForNextClick();
            
            highlightCodeLine(21); // return dest;
            explanationDisplay.textContent = "Loop de cópia concluído. A função retorna o ponteiro original para o destino.";
            await waitForNextClick();


            infoDisplay.textContent = "memcpy concluída. Note a corrupção de dados: 'C', 'D', 'E' originais foram perdidos.";
            explanationDisplay.textContent = "O array final é: " + currentArray.join('') + ". O comportamento é indefinido e perigoso com sobreposição!";
            animationRunning = false;
            disableControls(false);
            nextBtn.disabled = true;
            clearCodeHighlight();
        }

        async function animateMemmoveLogic() {
            displayCode(memmoveCode);

            highlightCodeLine(0);
            explanationDisplay.textContent = "Iniciando a função my_memmove. Ela recebe o destino, a origem e o número de bytes.";
            await waitForNextClick();

            highlightCodeLine(1);
            explanationDisplay.textContent = "Converte o ponteiro de destino 'void*' para 'char*'.";
            await waitForNextClick();

            highlightCodeLine(2);
            explanationDisplay.textContent = "Converte o ponteiro de origem 'const void*' para 'const char*'.";
            await waitForNextClick();

            highlightCodeLine(8); // if (n == 0)
            explanationDisplay.textContent = "Verificando se 'n' (número de bytes a copiar) é zero. Se for, não há cópia a fazer.";
            await waitForNextClick();

            highlightCodeLine(11); // d = (char *)dest;
            explanationDisplay.textContent = "Atribuindo os ponteiros convertidos 'dest' para 'd' e 'src' para 's'.";
            highlightCodeLine(12); // s = (const char *)src;
            await waitForNextClick();

            highlightCodeLine(15); // if (d > s && d < s + n) {
            explanationDisplay.textContent = "Verificando se as áreas de memória de origem e destino se sobrepõem e se o destino está à direita da origem. Isso determina a direção segura da cópia.";
            await waitForNextClick();


            const overlap = (destStart < srcStart + n) && (srcStart < destStart + n);
            const copyBackward = overlap && (destStart > srcStart);

            if (copyBackward) {
                copyDirection = 'backward';
                highlightCodeLine(16); // { (bloco if)
                explanationDisplay.textContent = "Condição VERDADEIRA! memmove detectou sobreposição e que o destino está à direita da origem. A cópia será feita de TRÁS PARA FRENTE para segurança.";
                await waitForNextClick();

                highlightCodeLine(18); // i = n;
                explanationDisplay.textContent = `Inicializando o contador 'i' para a cópia de trás para frente. 'i' começa em ${n}.`;
                await waitForNextClick();

                for (step = n; step > 0; step--) {
                    highlightCodeLine(19); // while (i > 0)
                    explanationDisplay.textContent = `Verificando a condição do loop: i (${step}) > 0. Condição verdadeira, entrando no loop.`;
                    await waitForNextClick();

                    highlightCodeLine(21); // i--;
                    explanationDisplay.textContent = `Decrementando 'i' para copiar o próximo byte de trás para frente. 'i' agora é ${step -1}.`;
                    await waitForNextClick();

                    highlightCodeLine(22); // d[i] = s[i];
                    const srcIdx = srcStart + (step - 1);
                    const destIdx = destStart + (step - 1);

                    highlightCells(srcIdx, destIdx, 'memmove');
                    let explanationText = `Passo ${n - step + 1} (De Trás): Lendo '${currentArray[srcIdx]}' de src[${srcIdx}]`;
                    explanationDisplay.textContent = explanationText;
                    await waitForNextClick();

                    const charToCopy = currentArray[srcIdx];

                    explanationText += ` e escrevendo em dest[${destIdx}]. Esta direção **EVITA** sobrescrever dados antes de serem lidos.`;
                    explanationDisplay.textContent = explanationText;
                    await waitForNextClick();

                    currentArray[destIdx] = charToCopy;
                    updateCellContent(destIdx, charToCopy);
                    await waitForNextClick(); // Pausa após cópia e explicação
                }
                highlightCodeLine(19); // Mostra a condição do while pela última vez (false)
                explanationDisplay.textContent = `Verificando a condição do loop: i (0) > 0. Condição falsa, saindo do loop.`;
                await waitForNextClick();

            } else {
                copyDirection = 'forward';
                highlightCodeLine(25); // } else {
                explanationDisplay.textContent = "Condição FALSA. memmove: Sem sobreposição ou destino à esquerda. Copiando de FRENTE PARA TRÁS.";
                await waitForNextClick();

                highlightCodeLine(27); // i = 0;
                explanationDisplay.textContent = `Inicializando o contador 'i' para a cópia de frente para trás. 'i' começa em 0.`;
                await waitForNextClick();

                for (step = 0; step < n; step++) {
                    highlightCodeLine(28); // while (i < n)
                    explanationDisplay.textContent = `Verificando a condição do loop: i (${step}) < n (${n}). Condição verdadeira, entrando no loop.`;
                    await waitForNextClick();

                    highlightCodeLine(30); // d[i] = s[i];
                    const srcIdx = srcStart + step;
                    const destIdx = destStart + step;

                    highlightCells(srcIdx, destIdx, 'memmove');
                    let explanationText = `Passo ${step + 1} (De Frente): Lendo '${currentArray[srcIdx]}' de src[${srcIdx}]`;
                    explanationDisplay.textContent = explanationText;
                    await waitForNextClick();

                    const charToCopy = currentArray[srcIdx];

                    explanationText += ` e escrevendo em dest[${destIdx}]. Não há risco de sobrescrita neste caso.`;
                    explanationDisplay.textContent = explanationText;
                    await waitForNextClick();

                    currentArray[destIdx] = charToCopy;
                    updateCellContent(destIdx, charToCopy);
                    await waitForNextClick(); // Pausa após cópia e explicação

                    highlightCodeLine(31); // i++;
                    explanationDisplay.textContent = `Incrementando 'i' para o próximo byte. i agora é ${step + 1}.`;
                    await waitForNextClick();
                }
                highlightCodeLine(28); // Mostra a condição do while pela última vez (false)
                explanationDisplay.textContent = `Verificando a condição do loop: i (${n}) < n (${n}). Condição falsa, saindo do loop.`;
                await waitForNextClick();
            }
            
            highlightCodeLine(35); // return dest;
            explanationDisplay.textContent = "Loop de cópia concluído. A função retorna o ponteiro original para o destino.";
            await waitForNextClick();

            infoDisplay.textContent = "memmove concluída. Cópia segura realizada.";
            explanationDisplay.textContent = "O array final é: " + currentArray.join('') + ". A cópia foi feita de forma segura.";
            animationRunning = false;
            disableControls(false);
            nextBtn.disabled = true;
            clearCodeHighlight();
        }

        function resetAnimation() {
            if (resolveNextStep) {
                resolveNextStep();
                resolveNextStep = null;
            }
            currentArray = [...initialArray];
            createMemoryDisplay();
            infoDisplay.textContent = "";
            explanationDisplay.textContent = "";
            animationRunning = false;
            step = 0;
            copyDirection = '';
            disableControls(false);
            nextBtn.disabled = true;
            clearCodeHighlight();
            codeDisplay.innerHTML = '';
        }

        function disableControls(disable) {
            memcpyBtn.disabled = disable;
            memmoveBtn.disabled = disable;
            resetBtn.disabled = disable;
            // nextBtn é controlado separadamente por waitForNextClick
        }

        async function startAnimation(type) {
            resetAnimation();
            animationRunning = true;
            currentAnimationType = type;
            disableControls(true); // Desabilita botões de simulação e reset

            // Habilita Next no início da animação
            nextBtn.disabled = false;

            if (type === 'memcpy') {
                await animateMemcpyLogic();
            } else {
                await animateMemmoveLogic();
            }
        }

        // Inicializa a exibição da memória ao carregar
        document.addEventListener('DOMContentLoaded', () => {
            createMemoryDisplay();
            showSection('animation'); // Mostra a seção de animação por padrão
        });
    </script>
</body>
</html>